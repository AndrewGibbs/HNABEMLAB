classdef HNAoverlappingMesh <basis
    
    properties
        %in parent basis
    end
    
    methods
        function self=HNAoverlappingMesh(obstacle, pMax, kwave, nLayers, sigmaGrad)
            %store key parameters
            self.pMax=pMax;
            self.nLayers=nLayers;
            self.sigmaGrad=sigmaGrad;
            
            %first construct the mesh
            mesh1=meshSide(obstacle, nLayers, sigmaGrad);
            mesh2=-mesh1;
            
            self.meshDOFs{1}=zeros(1,length(mesh1.el));
            self.meshDOFs{1}=zeros(1,length(mesh2.el));
            
            self.el=baseFnHNA(kwave,pMax,mesh1.el(1),0,mesh1.side);
            elCount=0;
            
            for m=1:length(mesh1.el)
                mesh1.el(m).pMax=pMaxChoose( mesh1.el(m).gradIndex, pMax, mesh1.minDex );
                for p=0:mesh1.el(m).pMax
                    elCount=elCount+1;
                    self.el(elCount)=baseFnHNA(kwave,p,mesh1.el(m),1,mesh1.side);
                    self.meshDOFs{1}(m)=mesh1.el(m).pMax+1;
                end
            end
            for m=1:length(mesh2.el)
                mesh2.el(m).pMax=pMaxChoose( mesh2.el(m).gradIndex, pMax, mesh2.minDex );
                for p=0:mesh2.el(m).pMax
                    elCount=elCount+1;
                    self.el(elCount)=baseFnHNA(kwave,p,mesh2.el(m),-1,mesh2.side);
                    self.meshDOFs{2}(m)=mesh2.el(m).pMax+1;
                end
            end
            
%            self.numEls=elCount;
            self.obstacle=obstacle;
            self.mesh{1}=mesh1;
            self.mesh{2}=mesh2;
            
            if isa(obstacle,'polygon')
                error('Overlapping mesh not yet compatible with polygons, use single mesh');
            else
                self.edgeBasis = []; %not sure what this does yet...
                self.elSide(1:length(self.el))=1;
            end
        end
        
        function [s, w] = getPoints(self,pointsPerWavelength,k,distType)
            if self.sigmaGrad>=.5
                error('Need smaller value of sigmaGrad to obtain mesh info');
            end
            %returns points with fixed number of nodes per mesh element,
            % distributed by distType = 'U' for uniform, 'G' for Gauss
            s = []; w=[];
            %numMeshEls = length(mesh{1}.el) + length(mesh{2}.el) ;
            
            meshPoints = unique(sort([self.mesh{1}.points self.mesh{2}.points]));
            numMeshEls = length(meshPoints)-1;
            %get widths
            for n = 1:(length(self.mesh{1}.el)-1)
                meshWidths(n) = self.mesh{1}.el(n).width;
            end
            meshWidths(n+1) = abs(self.mesh{2}.el(1).interval(2) - self.mesh{1}.el(end).interval(1));
            halfMeshWidthsLength = length(meshWidths);
            for n = 2:(length(self.mesh{2}.el))
                meshWidths(n+halfMeshWidthsLength-1) = self.mesh{2}.el(n).width;
            end
            
            for n = 1:numMeshEls
                
                if strcmp(distType,'U')
                    s_ = linspace(meshPoints(n), meshPoints(n+1), N).';
                    if n<numMeshEls
                        s_ = s_(1:(end-1));
                    end
                elseif strcmp(distType,'G')
                     [s_,w_] = gauss_quad_wave_split2(meshPoints(n), meshPoints(n+1),...
                                pointsPerWavelength, k,  meshWidths(n) );
                end
                s = [s; s_];
                w = [w; w_];
                clear s_ w_;
            end
        end
        
        function [fakeMesh DOFs] = mimicSingleMesh()
            fakeMesh.points = unique(sort([self.mesh{1}.points self.mesh{2}.points]));
            numMeshEls = length(meshPoints)-1;
            %get widths
            for n = 1:(length(self.mesh{1}.el)-1)
                fakeMesh.el(n).width = self.mesh{1}.el(n).width;
                fakeMesh.el(n).interval = self.mesh{1}.el(n).interval;
                fakeMesh.el(n).distL = self.mesh{1}.el(n).distL;
                fakeMesh.el(n).distR = self.mesh{1}.el(n).distR;
                DOFs(n) = self.meshDOFs{1}(n);
            end
            
            halfMeshWidthsLength = length(meshWidths);
            
            fakeMesh.el(n+1).width = abs(self.mesh{2}.el(1).interval(2) - self.mesh{1}.el(end).interval(1));
            fakeMesh.el(n+halfMeshWidthsLength-1).interval(self.mesh{1}.el(end).interval(1))
            DOFs(n+1) = self.meshDOFs{1}(end) + self.meshDOFs{2}(1);
            
            for n = 2:(length(self.mesh{2}.el))
                fakeMesh.el(n+halfMeshWidthsLength-1).width = self.mesh{2}.el(n).width;
                fakeMesh.el(n+halfMeshWidthsLength-1).interval = self.mesh{2}.el(n).interval;
                fakeMesh.el(n+halfMeshWidthsLength-1).distL = self.mesh{2}.el(n).distL;
                fakeMesh.el(n+halfMeshWidthsLength-1).distR = self.mesh{2}.el(n).distR;
                DOFs(n+halfMeshWidthsLength-1) = self.meshDOFs{2}(n);
            end
        end
    end
    
end